# -*- coding: utf-8 -*-
# Part of BrowseInfo. See LICENSE file for full copyright and licensing details.

from odoo import models, fields, api, _
from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, date_utils
from odoo.tools.misc import format_date
from datetime import datetime
from babel.dates import get_quarter_names


class AccountReport(models.AbstractModel):
    _inherit = 'account.report'

    filter_branch = True
    filter_accounts = None
    filter_date = {'date_from': '', 'date_to': '', 'mode': 'range', 'filter': 'this_month'}

    def _get_options(self, previous_options=None):
        if not previous_options:
            previous_options = {}
        options = super(AccountReport,
                        self)._get_options(previous_options)
        companies = options.get('multi_company')
        if options.get('branch'):
            options['branch'] = self._get_options_branch(
                companies=companies)
        # Merge old options with default from this report
        for key, value in options.items():
            if key in previous_options and value is not None and previous_options[key] is not None:
                if key == 'branch':
                    selected_branch = [previous_option for previous_option in previous_options[key] if previous_option in options[key]]
                    if selected_branch:
                        options[key] = selected_branch
        return options

    def _set_context(self, options):
        """This method will set information inside the context based on the options dict as some options need to be in context for the query_get method defined in account_move_line"""
        ctx = self.env.context.copy()
        if options.get('cash_basis'):
            ctx['cash_basis'] = True
        if options.get('date') and options['date'].get('date_from'):
            ctx['date_from'] = options['date']['date_from']
        if options.get('date'):
            ctx['date_to'] = options['date'].get(
                'date_to') or options['date'].get('date')
        if options.get('all_entries') is not None:
            ctx['state'] = options.get('all_entries') and 'all' or 'posted'
        if options.get('journals'):
            ctx['journal_ids'] = [j.get('id') for j in options.get(
                'journals') if j.get('selected')]
        company_ids = []
        if options.get('multi_company'):
            company_ids = [
                c.get('id') for c in options['multi_company'] if c.get('selected')]
            company_ids = company_ids if len(company_ids) > 0 else [
                c.get('id') for c in options['multi_company']]
        ctx['company_ids'] = len(company_ids) > 0 and company_ids or [
            self.env.user.company_id.id]

        if options.get('branch'):
            ctx['branch'] = self.env['res.branch'].browse(
                [int(acc) for acc in options['branch']])

        if options.get('analytic_accounts'):
            ctx['analytic_account_ids'] = self.env['account.analytic.account'].browse(
                [int(acc) for acc in options['analytic_accounts']])
        if options.get('analytic_tags'):
            ctx['analytic_tag_ids'] = self.env['account.analytic.tag'].browse(
                [int(t) for t in options['analytic_tags']])
        if options.get('partner_ids'):
            ctx['partner_ids'] = self.env['res.partner'].browse(
                [int(partner) for partner in options['partner_ids']])
        if options.get('partner_categories'):
            ctx['partner_categories'] = self.env['res.partner.category'].browse(
                [int(category) for category in options['partner_categories']])
        return ctx

    def _get_options_branch(self, account_type=None, companies=None):
        domain = []
        if companies:
            company_ids = [c.get('id') for c in companies if c.get('selected')]
            if company_ids:
                domain.append(('company_id', 'in', company_ids))
        branch = self.env['res.branch'].search(domain).ids
        return branch

    def get_report_informations(self, options):
        '''
        return a dictionary of informations that will be needed by the js widget, manager_id, footnotes, html of report and searchview, ...
        '''
        options = self._get_options(options)
        # apply date and date_comparison filter
        # self._apply_date_filter(options)

        searchview_dict = {'options': options, 'context': self.env.context}
        # Check if report needs analytic
        searchview_dict['branch'] = [(t.id, t.name) for t in self.env['res.branch'].search([])] or False
        options['selected_branch_names'] = [self.env['res.branch'].browse(int(tag)).name for tag in options['branch']]
        if options.get('analytic_accounts') is not None:
            searchview_dict['analytic_accounts'] = self.env.user.id in self.env.ref('analytic.group_analytic_accounting').users.ids and [
                (t.id, t.name) for t in self.env['account.analytic.account'].search([])] or False
            options['selected_analytic_account_names'] = [self.env['account.analytic.account'].browse(
                int(account)).name for account in options['analytic_accounts']]
        if options.get('analytic_tags') is not None:
            searchview_dict['analytic_tags'] = self.env.user.id in self.env.ref('analytic.group_analytic_tags').users.ids and [
                (t.id, t.name) for t in self.env['account.analytic.tag'].search([])] or False
            options['selected_analytic_tag_names'] = [self.env['account.analytic.tag'].browse(
                int(tag)).name for tag in options['analytic_tags']]
        if options.get('partner'):
            options['selected_partner_ids'] = [self.env['res.partner'].browse(
                int(partner)).name for partner in options['partner_ids']]
            options['selected_partner_categories'] = [self.env['res.partner.category'].browse(
                int(category)).name for category in options['partner_categories']]

        # Check whether there are unposted entries for the selected period or not (if the report allows it)
        if options.get('date') and options.get('all_entries') is not None:
            date_to = options['date'].get('date_to') or options['date'].get(
                'date') or fields.Date.today()
            period_domain = [('state', '=', 'draft'), ('date', '<=', date_to)]
            options['unposted_in_period'] = bool(
                self.env['account.move'].search_count(period_domain))

        report_manager = self._get_report_manager(options)
        info = {'options': options,
                'context': self.env.context,
                'report_manager_id': report_manager.id,
                'footnotes': [{'id': f.id, 'line': f.line, 'text': f.text} for f in report_manager.footnotes_ids],
                'buttons': self._get_reports_buttons(options),
                'main_html': self.get_html(options),
                'searchview_html': self.env['ir.ui.view']._render_template(self._get_templates().get('search_template', 'account_report.search_template'), values=searchview_dict),
                }
        return info

    def _get_dates_period(self, options, date_from, date_to, mode=None, period_type=None, strict_range=False):
        '''Compute some information about the period:
        * The name to display on the report.
        * The period type (e.g. quarter) if not specified explicitly.

        :param options:     The report options.
        :param date_from:   The starting date of the period.
        :param date_to:     The ending date of the period.
        :param period_type: The type of the interval date_from -> date_to.
        :return:            A dictionary containing:
            * date_from * date_to * string * period_type *
        '''
        def match(dt_from, dt_to):
            # if self.has_single_date_filter(options):
            #     return (date_to or date_from) == dt_to
            # else:
            return (dt_from, dt_to) == (date_from, date_to)

        string = None
        # If no date_from or not date_to, we are unable to determine a period
        if not period_type:
            date = date_to or date_from or datetime.today().date()
            company_fiscalyear_dates = self.env.user.company_id.compute_fiscalyear_dates(
                date)
            if match(company_fiscalyear_dates['date_from'], company_fiscalyear_dates['date_to']):
                period_type = 'fiscalyear'
                if company_fiscalyear_dates.get('record'):
                    string = company_fiscalyear_dates['record'].name
            elif match(*date_utils.get_month(date)):
                period_type = 'month'
            elif match(*date_utils.get_quarter(date)):
                period_type = 'quarter'
            elif match(*date_utils.get_fiscal_year(date)):
                period_type = 'year'
            else:
                period_type = 'custom'

        if not string:
            fy_day = self.env.user.company_id.fiscalyear_last_day
            fy_month = self.env.user.company_id.fiscalyear_last_month
            date_to = fields.Date.context_today(
                self) if not date_to else date_to
            # if self.has_single_date_filter(options):
            #     string = _('As of %s') % (format_date(
            #         self.env, date_to.strftime(DEFAULT_SERVER_DATE_FORMAT)))
            if period_type == 'year' or (period_type == 'fiscalyear' and (date_from, date_to) == date_utils.get_fiscal_year(date_to)):
                string = date_to.strftime('%Y')
            elif period_type == 'fiscalyear' and (date_from, date_to) == date_utils.get_fiscal_year(date_to, day=fy_day, month=fy_month):
                string = '%s - %s' % (date_to.year - 1, date_to.year)
            elif period_type == 'month':
                string = format_date(self.env, date_to.strftime(
                    DEFAULT_SERVER_DATE_FORMAT), date_format='MMM YYYY')
            elif period_type == 'quarter':
                quarter_names = get_quarter_names(
                    'abbreviated', locale=self.env.context.get('lang') or 'en_US')
                string = u'%s\N{NO-BREAK SPACE}%s' % (
                    quarter_names[date_utils.get_quarter_number(date_to)], date_to.year)
            else:
                if not date_from:
                    if date_to:
                        date_from = date_to.replace(day=1)
                    else:
                        date_to = datetime.today()
                        date_from = date_to.replace(day=1)
                dt_from_str = format_date(
                    self.env, date_from.strftime(DEFAULT_SERVER_DATE_FORMAT))
                dt_to_str = format_date(
                    self.env, date_to.strftime(DEFAULT_SERVER_DATE_FORMAT))
                string = _('From %s \n to  %s') % (dt_from_str, dt_to_str)
        date_from = date_from.strftime('%Y-%m-%d')
        date_to = date_to.strftime('%Y-%m-%d')
        return {
            'string': string,
            'period_type': period_type,
            'date_from': date_from,
            'date_to': date_to,
            'strict_range': strict_range,
            'mode': mode
        }


# vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4:
